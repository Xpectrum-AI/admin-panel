name: Deploy to Release

on:
  push:
    branches: [ 'release-*' ] 
  workflow_dispatch:
    inputs:
      image_tag_suffix:
        description: 'Image tag suffix (e.g., 2025w01)'
        required: false
        type: string

env:
  AWS_REGION: us-west-1
  ACCOUNT_ID: 503561436224

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
 
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        run: |
          cd frontend
          npm ci

      - name: Lint frontend
        run: |
          cd frontend
          npm run lint || echo "Lint completed with warnings"

      - name: Type check frontend
        run: |
          cd frontend
          npx tsc --noEmit || echo "Type check completed with warnings"

      - name: Run tests
        run: |
          cd frontend
          npm test -- --coverage --watchAll=false



  deploy-release:
    runs-on: ubuntu-latest
    environment: production
    needs: test  
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_PROD_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_PROD_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Determine image tags
      id: image-tags
      run: |
        # å¦‚æžœæä¾›äº† image_tag_suffixï¼Œä½¿ç”¨å®ƒ
        if [ -n "${{ inputs.image_tag_suffix }}" ]; then
          TAG_SUFFIX="${{ inputs.image_tag_suffix }}"
        # å¦‚æžœæ˜¯ release åˆ†æ”¯ï¼Œä»Žåˆ†æ”¯åæå–å‘¨æ•°
        elif [[ "${{ github.ref_name }}" == release-* ]]; then
          TAG_SUFFIX=$(echo "${{ github.ref_name }}" | sed 's/release-//')
        else
          # é»˜è®¤ä½¿ç”¨æ—¶é—´æˆ³
          TAG_SUFFIX=$(date +%Y%m%d-%H%M%S)
        fi
        
        # è®¾ç½®å®Œæ•´çš„æ ‡ç­¾
        MAIN_IMAGE_TAG="frontend-release-${TAG_SUFFIX}"
        DEVELOPER_IMAGE_TAG="frontend-developer-release-${TAG_SUFFIX}"
        
        echo "Using main image tag: $MAIN_IMAGE_TAG"
        echo "Using developer image tag: $DEVELOPER_IMAGE_TAG"
        echo "main_image_tag=$MAIN_IMAGE_TAG" >> $GITHUB_OUTPUT
        echo "developer_image_tag=$DEVELOPER_IMAGE_TAG" >> $GITHUB_OUTPUT

    - name: Build and push Main Frontend image to ECR
      env:
        NEXT_PUBLIC_LIVE_API_URL: ${{ vars.PRODUCTION_LIVE_API_URL }}
        NEXT_PUBLIC_PROPELAUTH_URL: ${{ vars.PRODUCTION_PROPELAUTH_URL }}
        NEXT_PUBLIC_LIVE_API_KEY: ${{ secrets.PRODUCTION_LIVE_API_KEY }}
        NEXT_PUBLIC_PROPELAUTH_API_KEY: ${{ secrets.PRODUCTION_PROPELAUTH_API_KEY }}
        NEXT_PUBLIC_SUPER_ADMIN_ORG_ID: ${{ secrets.PRODUCTION_SUPER_ADMIN_ORG_ID }}
        MAIN_IMAGE_TAG: ${{ steps.image-tags.outputs.main_image_tag }}
      run: |
        # Set ECR repository URI
        REPO="${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/admin-panel"
        
        # Verify MAIN_IMAGE_TAG is set
        if [ -z "$MAIN_IMAGE_TAG" ]; then
          echo "Error: MAIN_IMAGE_TAG is not set"
          exit 1
        fi
        
        echo "Building main frontend with image tag: $MAIN_IMAGE_TAG"
        
        # Build, tag, and push main frontend with environment variables
        cd frontend
        docker build \
          --build-arg NEXT_PUBLIC_LIVE_API_URL="${NEXT_PUBLIC_LIVE_API_URL}" \
          --build-arg NEXT_PUBLIC_PROPELAUTH_URL="${NEXT_PUBLIC_PROPELAUTH_URL}" \
          --build-arg NEXT_PUBLIC_LIVE_API_KEY="${NEXT_PUBLIC_LIVE_API_KEY}" \
          --build-arg NEXT_PUBLIC_PROPELAUTH_API_KEY="${NEXT_PUBLIC_PROPELAUTH_API_KEY}" \
          --build-arg NEXT_PUBLIC_SUPER_ADMIN_ORG_ID="${NEXT_PUBLIC_SUPER_ADMIN_ORG_ID}" \
          -t admin-panel:$MAIN_IMAGE_TAG .
        docker tag admin-panel:$MAIN_IMAGE_TAG $REPO:$MAIN_IMAGE_TAG
        docker push $REPO:$MAIN_IMAGE_TAG
        docker tag admin-panel:$MAIN_IMAGE_TAG $REPO:frontend-release-latest
        docker push $REPO:frontend-release-latest
        cd ..

    - name: Build and push Developer Frontend image to ECR
      env:
        NEXT_PUBLIC_LIVE_API_URL: ${{ vars.PRODUCTION_LIVE_API_URL }}
        NEXT_PUBLIC_PROPELAUTH_URL: ${{ vars.PRODUCTION_DEVELOPER_PROPELAUTH_URL }}
        NEXT_PUBLIC_LIVE_API_KEY: ${{ secrets.PRODUCTION_LIVE_API_KEY }}
        NEXT_PUBLIC_PROPELAUTH_API_KEY: ${{ secrets.PRODUCTION_DEVELOPER_PROPELAUTH_API_KEY }}
        NEXT_PUBLIC_MODEL_API_BASE_URL: ${{ vars.PRODUCTION_MODEL_API_BASE_URL }}
        NEXT_PUBLIC_MODEL_API_KEY: ${{ secrets.PRODUCTION_MODEL_API_KEY }}
        NEXT_PUBLIC_CHATBOT_API_URL: ${{ vars.PRODUCTION_CHATBOT_API_URL }}
        NEXT_PUBLIC_CHATBOT_API_KEY: ${{ secrets.PRODUCTION_CHATBOT_API_KEY }}
        NEXT_PUBLIC_ELEVEN_LABS_API_KEY: ${{ secrets.PRODUCTION_ELEVEN_LABS_API_KEY }}
        NEXT_PUBLIC_OPEN_AI_API_KEY: ${{ secrets.PRODUCTION_OPEN_AI_API_KEY }}
        NEXT_PUBLIC_WHISPER_API_KEY: ${{ secrets.PRODUCTION_WHISPER_API_KEY }}
        NEXT_PUBLIC_DEEPGRAM_API_KEY: ${{ secrets.PRODUCTION_DEEPGRAM_API_KEY }}
        NEXT_PUBLIC_CARTESIA_API_KEY: ${{ secrets.PRODUCTION_CARTESIA_API_KEY }}
        NEXT_PUBLIC_CARTESIA_VOICE_ID: ${{ vars.PRODUCTION_CARTESIA_VOICE_ID }}
        NEXT_PUBLIC_ELEVEN_LABS_VOICE_ID: ${{ vars.PRODUCTION_ELEVEN_LABS_VOICE_ID }}
        DEVELOPER_IMAGE_TAG: ${{ steps.image-tags.outputs.developer_image_tag }}
      run: |
        # Set ECR repository URI
        REPO="${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/admin-panel"
        
        # Verify DEVELOPER_IMAGE_TAG is set
        if [ -z "$DEVELOPER_IMAGE_TAG" ]; then
          echo "Error: DEVELOPER_IMAGE_TAG is not set"
          exit 1
        fi
        
        echo "Building developer frontend with image tag: $DEVELOPER_IMAGE_TAG"
        
        # Build, tag, and push developer frontend with environment variables
        cd frontend-developer
        docker build \
          --build-arg NEXT_PUBLIC_LIVE_API_URL="${NEXT_PUBLIC_LIVE_API_URL}" \
          --build-arg NEXT_PUBLIC_PROPELAUTH_URL="${NEXT_PUBLIC_PROPELAUTH_URL}" \
          --build-arg NEXT_PUBLIC_LIVE_API_KEY="${NEXT_PUBLIC_LIVE_API_KEY}" \
          --build-arg NEXT_PUBLIC_PROPELAUTH_API_KEY="${NEXT_PUBLIC_PROPELAUTH_API_KEY}" \
          --build-arg NEXT_PUBLIC_MODEL_API_BASE_URL="${NEXT_PUBLIC_MODEL_API_BASE_URL}" \
          --build-arg NEXT_PUBLIC_MODEL_API_KEY="${NEXT_PUBLIC_MODEL_API_KEY}" \
          --build-arg NEXT_PUBLIC_CHATBOT_API_URL="${NEXT_PUBLIC_CHATBOT_API_URL}" \
          --build-arg NEXT_PUBLIC_CHATBOT_API_KEY="${NEXT_PUBLIC_CHATBOT_API_KEY}" \
          --build-arg NEXT_PUBLIC_ELEVEN_LABS_API_KEY="${NEXT_PUBLIC_ELEVEN_LABS_API_KEY}" \
          --build-arg NEXT_PUBLIC_OPEN_AI_API_KEY="${NEXT_PUBLIC_OPEN_AI_API_KEY}" \
          --build-arg NEXT_PUBLIC_WHISPER_API_KEY="${NEXT_PUBLIC_WHISPER_API_KEY}" \
          --build-arg NEXT_PUBLIC_DEEPGRAM_API_KEY="${NEXT_PUBLIC_DEEPGRAM_API_KEY}" \
          --build-arg NEXT_PUBLIC_CARTESIA_API_KEY="${NEXT_PUBLIC_CARTESIA_API_KEY}" \
          --build-arg NEXT_PUBLIC_CARTESIA_VOICE_ID="${NEXT_PUBLIC_CARTESIA_VOICE_ID}" \
          --build-arg NEXT_PUBLIC_ELEVEN_LABS_VOICE_ID="${NEXT_PUBLIC_ELEVEN_LABS_VOICE_ID}" \
          -t admin-panel:$DEVELOPER_IMAGE_TAG .
        docker tag admin-panel:$DEVELOPER_IMAGE_TAG $REPO:$DEVELOPER_IMAGE_TAG
        docker push $REPO:$DEVELOPER_IMAGE_TAG
        docker tag admin-panel:$DEVELOPER_IMAGE_TAG $REPO:frontend-developer-release-latest
        docker push $REPO:frontend-developer-release-latest
        cd ..

    - name: Setup Python for CDK
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Install CDK dependencies
      run: |
        cd python-cdk-v2
        pip install -r requirements.txt

    - name: Install AWS CDK
      run: |
        npm install -g aws-cdk
    
    - name: Deploy CDK stack (releasing)
      env:
        # Image tags
        RELEASE_IMAGE_TAG: ${{ steps.image-tags.outputs.main_image_tag }}
        RELEASE_DEVELOPER_IMAGE_TAG: ${{ steps.image-tags.outputs.developer_image_tag }}
        # Backend API
        PRODUCTION_LIVE_API_URL: ${{ vars.PRODUCTION_LIVE_API_URL }}
        PRODUCTION_LIVE_API_KEY: ${{ secrets.PRODUCTION_LIVE_API_KEY }}
        # PropelAuth
        PRODUCTION_PROPELAUTH_URL: ${{ vars.PRODUCTION_PROPELAUTH_URL }}
        PRODUCTION_PROPELAUTH_API_KEY: ${{ secrets.PRODUCTION_PROPELAUTH_API_KEY }}
        PRODUCTION_DEVELOPER_PROPELAUTH_URL: ${{ vars.PRODUCTION_DEVELOPER_PROPELAUTH_URL }}
        PRODUCTION_DEVELOPER_PROPELAUTH_API_KEY: ${{ secrets.PRODUCTION_DEVELOPER_PROPELAUTH_API_KEY }}
        # Model Configuration API
        PRODUCTION_MODEL_API_BASE_URL: ${{ vars.PRODUCTION_MODEL_API_BASE_URL }}
        PRODUCTION_MODEL_API_KEY: ${{ secrets.PRODUCTION_MODEL_API_KEY }}
        # Chatbot API
        PRODUCTION_CHATBOT_API_URL: ${{ vars.PRODUCTION_CHATBOT_API_URL }}
        PRODUCTION_CHATBOT_API_KEY: ${{ secrets.PRODUCTION_CHATBOT_API_KEY }}
        # Voice Provider API Keys
        PRODUCTION_ELEVEN_LABS_API_KEY: ${{ secrets.PRODUCTION_ELEVEN_LABS_API_KEY }}
        PRODUCTION_OPEN_AI_API_KEY: ${{ secrets.PRODUCTION_OPEN_AI_API_KEY }}
        PRODUCTION_WHISPER_API_KEY: ${{ secrets.PRODUCTION_WHISPER_API_KEY }}
        PRODUCTION_DEEPGRAM_API_KEY: ${{ secrets.PRODUCTION_DEEPGRAM_API_KEY }}
        PRODUCTION_CARTESIA_API_KEY: ${{ secrets.PRODUCTION_CARTESIA_API_KEY }}
        # Voice Provider Voice IDs
        PRODUCTION_CARTESIA_VOICE_ID: ${{ vars.PRODUCTION_CARTESIA_VOICE_ID }}
        PRODUCTION_ELEVEN_LABS_VOICE_ID: ${{ vars.PRODUCTION_ELEVEN_LABS_VOICE_ID }}
      run: |
        cd python-cdk-v2
        
        echo "=== CDK DEPLOYMENT DEBUG ==="
        echo "Current directory: $(pwd)"
        echo "Environment variables are now handled during Docker build"
        echo "RELEASE_IMAGE_TAG: $RELEASE_IMAGE_TAG"
        echo "RELEASE_DEVELOPER_IMAGE_TAG: $RELEASE_DEVELOPER_IMAGE_TAG"
        echo "====================================="
        
        # Deploy to release environment with release context
        # Add timeout to prevent hanging
        timeout 30m cdk deploy AdminPanelReleaseStack --require-approval never --context environment=release || {
          echo "CDK deployment timed out or failed"
          echo "Checking ECS service status..."
          aws ecs describe-services \
            --cluster admin-panel-release \
            --services admin-panel-service-release admin-panel-developer-service-release \
            --region ${{ env.AWS_REGION }} || echo "Could not check ECS status"
          exit 1
        }
    
    - name: Wait for deployment to complete
      run: |
        # Check if stack exists first
        if aws cloudformation describe-stacks --stack-name AdminPanelReleaseStack --region ${{ env.AWS_REGION }} 2>/dev/null; then
          echo "Waiting for services to stabilize..."
          # æ³¨æ„ï¼šè¿™é‡Œéœ€è¦åœ¨ç¬¬ä¸€æ¬¡éƒ¨ç½²åŽæ›´æ–°å®žé™…çš„é›†ç¾¤å’ŒæœåŠ¡åç§°
          # aws ecs wait services-stable \
          #   --cluster admin-panel-release \
          #   --services admin-panel-service-release \
          #   --region ${{ env.AWS_REGION }} || echo "Services not stable yet"
        else
          echo "Stack does not exist yet, skipping wait"
        fi

    - name: Get ALB DNS names
      id: alb-dns
      run: |
        DOCTOR_DNS=$(aws cloudformation describe-stacks \
          --stack-name AdminPanelReleaseStack \
          --query 'Stacks[0].Outputs[?OutputKey==`DoctorServiceURL`].OutputValue' \
          --output text \
          --region ${{ env.AWS_REGION }})
        DEVELOPER_DNS=$(aws cloudformation describe-stacks \
          --stack-name AdminPanelReleaseStack \
          --query 'Stacks[0].Outputs[?OutputKey==`DeveloperServiceURL`].OutputValue' \
          --output text \
          --region ${{ env.AWS_REGION }})
        echo "doctor-dns=$DOCTOR_DNS" >> $GITHUB_OUTPUT
        echo "developer-dns=$DEVELOPER_DNS" >> $GITHUB_OUTPUT
        echo "Doctor Service URL: $DOCTOR_DNS"
        echo "Developer Service URL: $DEVELOPER_DNS"

    - name: Health check
      run: |
        # Wait for services to be fully ready
        sleep 60
        
        # Get ALB DNS names for both services
        DOCTOR_DNS=$(aws cloudformation describe-stacks \
          --stack-name AdminPanelReleaseStack \
          --query 'Stacks[0].Outputs[?OutputKey==`DoctorServiceURL`].OutputValue' \
          --output text \
          --region ${{ env.AWS_REGION }})
        
        DEVELOPER_DNS=$(aws cloudformation describe-stacks \
          --stack-name AdminPanelReleaseStack \
          --query 'Stacks[0].Outputs[?OutputKey==`DeveloperServiceURL`].OutputValue' \
          --output text \
          --region ${{ env.AWS_REGION }})
        
        # Check if DNS names are not empty
        if [ -z "$DOCTOR_DNS" ] || [ "$DOCTOR_DNS" = "None" ]; then
          echo "Error: Could not get Doctor service DNS name from CloudFormation stack"
          exit 1
        fi
        
        if [ -z "$DEVELOPER_DNS" ] || [ "$DEVELOPER_DNS" = "None" ]; then
          echo "Error: Could not get Developer service DNS name from CloudFormation stack"
          exit 1
        fi
        
        echo "Doctor Service URL: $DOCTOR_DNS"
        echo "Developer Service URL: $DEVELOPER_DNS"
        
        # Health checks for Doctor service (main frontend)
        curl -f -k "$DOCTOR_DNS/" || exit 1
        curl -f -k "$DOCTOR_DNS/api/health" || exit 1
        
        # Health checks for Developer service (separate domain)
        curl -f -k "$DEVELOPER_DNS/" || exit 1
        curl -f -k "$DEVELOPER_DNS/api/health" || exit 1

    - name: Force restart ECS services
      run: |
        aws ecs update-service \
          --cluster "admin-panel-release" \
          --service "admin-panel-service-release" \
          --force-new-deployment \
          --region "$AWS_REGION"
        
        aws ecs update-service \
          --cluster "admin-panel-release" \
          --service "admin-panel-developer-service-release" \
          --force-new-deployment \
          --region "$AWS_REGION"
        
    - name: Debug deployment status
      run: |
        echo "=== Checking CloudFormation stack status ==="
        aws cloudformation describe-stacks \
          --stack-name AdminPanelReleaseStack \
          --region ${{ env.AWS_REGION }} \
          --query 'Stacks[0].StackStatus' \
          --output text || echo "Stack not found"
        
        echo "=== Getting actual ECS resources ==="
        # èŽ·å–å®žé™…çš„é›†ç¾¤åç§°
        CLUSTER_NAME="admin-panel-release"
        SERVICE_NAME="admin-panel-service-release"
        if [ ! -z "$CLUSTER_NAME" ]; then
          echo "Found cluster: $CLUSTER_NAME"
          
          # èŽ·å–æœåŠ¡åç§°
          if [ ! -z "$SERVICE_NAME" ]; then
            echo "Found service: $SERVICE_NAME"
            
            # æ£€æŸ¥æœåŠ¡çŠ¶æ€
            aws ecs describe-services \
              --cluster $CLUSTER_NAME \
              --services $SERVICE_NAME \
              --region ${{ env.AWS_REGION }} \
              --query 'services[0].{status:status,desiredCount:desiredCount,runningCount:runningCount,pendingCount:pendingCount}' \
              --output table || echo "Could not check ECS status"
          fi
        fi

    - name: Debug ECS task failures
      if: always()
      run: |
        echo "=== Checking for ECS tasks ==="
        # èŽ·å–é›†ç¾¤åç§°
        CLUSTER_NAME="admin-panel-release"
        
        if [ ! -z "$CLUSTER_NAME" ]; then
          TASK_ARNS=$(aws ecs list-tasks \
            --cluster $CLUSTER_NAME \
            --region ${{ env.AWS_REGION }} \
            --query 'taskArns' \
            --output text 2>/dev/null || echo "")
          
          if [ ! -z "$TASK_ARNS" ]; then
            echo "=== Task Details ==="
            aws ecs describe-tasks \
              --cluster $CLUSTER_NAME \
              --tasks $TASK_ARNS \
              --region ${{ env.AWS_REGION }} \
              --query 'tasks[].{taskArn:taskArn,lastStatus:lastStatus,desiredStatus:desiredStatus,stoppedReason:stoppedReason,healthStatus:healthStatus}' \
              --output table || echo "Could not get task details"
          else
            echo "No tasks found"
          fi
        fi

    - name: Create deployment summary
      if: success()
      run: |
        echo "## Release Deployment Successful! ðŸš€" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "- **Branch**: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Main Image Tag**: ${{ steps.image-tags.outputs.main_image_tag }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Developer Image Tag**: ${{ steps.image-tags.outputs.developer_image_tag }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Doctor Service URL**: ${{ steps.alb-dns.outputs.doctor-dns }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Developer Service URL**: ${{ steps.alb-dns.outputs.developer-dns }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Deployed At**: $(date)" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Release Information" >> $GITHUB_STEP_SUMMARY
        echo "- **Week Number**: $(echo ${{ github.ref_name }} | sed 's/release-//')" >> $GITHUB_STEP_SUMMARY
        echo "- **Main Release Tag**: frontend-release-latest" >> $GITHUB_STEP_SUMMARY
        echo "- **Developer Release Tag**: frontend-developer-release-latest" >> $GITHUB_STEP_SUMMARY

  deployment-failure:
    needs: deploy-release
    runs-on: ubuntu-latest
    if: failure()
    steps:
      - name: Release Deployment Failed
        run: |
          echo "Release deployment failed - check the logs for details"
          echo "## Release Deployment Failed! âŒ" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch**: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Failed At**: $(date)" >> $GITHUB_STEP_SUMMARY
