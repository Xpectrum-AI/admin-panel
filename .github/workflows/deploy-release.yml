name: Deploy to Release

on:
  push:
    branches: [ 'release-*' ] 
  workflow_dispatch:
    inputs:
      image_tag_suffix:
        description: 'Image tag suffix (e.g., 2025w01)'
        required: false
        type: string

env:
  AWS_REGION: us-west-1
  ACCOUNT_ID: 503561436224

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
 
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        run: |
          cd frontend
          npm ci

      - name: Lint frontend
        run: |
          cd frontend
          npm run lint || echo "Lint completed with warnings"

      - name: Type check frontend
        run: |
          cd frontend
          npx tsc --noEmit || echo "Type check completed with warnings"

      - name: Run tests
        run: |
          cd frontend
          npm test -- --coverage --watchAll=false

  deploy-release:
    runs-on: ubuntu-latest
    environment: production
    needs: test
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_PROD_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_PROD_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Determine image tag
      id: image-tag
      run: |
        # å¦‚æžœæä¾›äº† image_tag_suffixï¼Œä½¿ç”¨å®ƒ
        if [ -n "${{ inputs.image_tag_suffix }}" ]; then
          TAG_SUFFIX="${{ inputs.image_tag_suffix }}"
        # å¦‚æžœæ˜¯ release åˆ†æ”¯ï¼Œä»Žåˆ†æ”¯åæå–å‘¨æ•°
        elif [[ "${{ github.ref_name }}" == release-* ]]; then
          TAG_SUFFIX=$(echo "${{ github.ref_name }}" | sed 's/release-//')
        else
          # é»˜è®¤ä½¿ç”¨æ—¶é—´æˆ³
          TAG_SUFFIX=$(date +%Y%m%d-%H%M%S)
        fi
        
        # è®¾ç½®å®Œæ•´çš„æ ‡ç­¾
        IMAGE_TAG="frontend-release-${TAG_SUFFIX}"
        
        echo "Using image tag: $IMAGE_TAG"
        echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT

    - name: Build and push Frontend image to ECR
      env:
        NEXT_PUBLIC_LIVE_API_URL: ${{ vars.PRODUCTION_LIVE_API_URL }}
        NEXT_PUBLIC_PROPELAUTH_URL: ${{ vars.PRODUCTION_PROPELAUTH_URL }}
        NEXT_PUBLIC_LIVE_API_KEY: ${{ secrets.PRODUCTION_LIVE_API_KEY }}
        NEXT_PUBLIC_PROPELAUTH_API_KEY: ${{ secrets.PRODUCTION_PROPELAUTH_API_KEY }}
        NEXT_PUBLIC_SUPER_ADMIN_ORG_ID: ${{ secrets.PRODUCTION_SUPER_ADMIN_ORG_ID }}
        IMAGE_TAG: ${{ steps.image-tag.outputs.image_tag }}
      run: |
        # Set ECR repository URI
        REPO="${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/admin-panel"
        
        # Verify IMAGE_TAG is set
        if [ -z "$IMAGE_TAG" ]; then
          echo "Error: IMAGE_TAG is not set"
          exit 1
        fi
        
        echo "Building with image tag: $IMAGE_TAG"
        
        # Build, tag, and push frontend only with environment variables
        cd frontend
        docker build \
          --build-arg NEXT_PUBLIC_LIVE_API_URL="${NEXT_PUBLIC_LIVE_API_URL}" \
          --build-arg NEXT_PUBLIC_PROPELAUTH_URL="${NEXT_PUBLIC_PROPELAUTH_URL}" \
          --build-arg NEXT_PUBLIC_LIVE_API_KEY="${NEXT_PUBLIC_LIVE_API_KEY}" \
          --build-arg NEXT_PUBLIC_PROPELAUTH_API_KEY="${NEXT_PUBLIC_PROPELAUTH_API_KEY}" \
          --build-arg NEXT_PUBLIC_SUPER_ADMIN_ORG_ID="${NEXT_PUBLIC_SUPER_ADMIN_ORG_ID}" \
          -t admin-panel:$IMAGE_TAG .
        docker tag admin-panel:$IMAGE_TAG $REPO:$IMAGE_TAG
        docker push $REPO:$IMAGE_TAG
        docker tag admin-panel:$IMAGE_TAG $REPO:frontend-release-latest
        docker push $REPO:frontend-release-latest
        cd ..

    - name: Setup Python for CDK
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Install CDK dependencies
      run: |
        cd python-cdk-v2
        pip install -r requirements.txt

    - name: Install AWS CDK
      run: |
        npm install -g aws-cdk
    
    - name: Deploy CDK stack (releasing)
      run: |
        cd python-cdk-v2
        
        echo "=== CDK DEPLOYMENT DEBUG ==="
        echo "Current directory: $(pwd)"
        echo "Environment variables are now handled during Docker build"
        echo "====================================="
        
        # Deploy to release environment with release context
        # Add timeout to prevent hanging
        timeout 30m cdk deploy AdminPanelReleaseStack --require-approval never --context environment=release || {
          echo "CDK deployment timed out or failed"
          echo "Checking ECS service status..."
          aws ecs describe-services \
            --cluster admin-panel-release \
            --services admin-panel-service-release  \
            --region ${{ env.AWS_REGION }} || echo "Could not check ECS status"
          exit 1
        }
    
    - name: Wait for deployment to complete
      run: |
        # Check if stack exists first
        if aws cloudformation describe-stacks --stack-name AdminPanelReleaseStack --region ${{ env.AWS_REGION }} 2>/dev/null; then
          echo "Waiting for services to stabilize..."
          # æ³¨æ„ï¼šè¿™é‡Œéœ€è¦åœ¨ç¬¬ä¸€æ¬¡éƒ¨ç½²åŽæ›´æ–°å®žé™…çš„é›†ç¾¤å’ŒæœåŠ¡åç§°
          # aws ecs wait services-stable \
          #   --cluster admin-panel-release \
          #   --services admin-panel-service-release \
          #   --region ${{ env.AWS_REGION }} || echo "Services not stable yet"
        else
          echo "Stack does not exist yet, skipping wait"
        fi

    - name: Get ALB DNS name
      id: alb-dns
      run: |
        DNS_NAME=$(aws cloudformation describe-stacks \
          --stack-name AdminPanelReleaseStack \
          --query 'Stacks[0].Outputs[?OutputKey==`FrontendURL`].OutputValue' \
          --output text \
          --region ${{ env.AWS_REGION }})
        echo "alb-dns=$DNS_NAME" >> $GITHUB_OUTPUT
        echo "Frontend URL: $DNS_NAME"

    - name: Health check
      run: |
        # Wait for services to be fully ready
        sleep 60
        
        # Get ALB DNS name
        DNS_NAME=$(aws cloudformation describe-stacks \
          --stack-name AdminPanelReleaseStack \
          --query 'Stacks[0].Outputs[?OutputKey==`FrontendURL`].OutputValue' \
          --output text \
          --region ${{ env.AWS_REGION }})
        
        # Check if DNS_NAME is not empty
        if [ -z "$DNS_NAME" ] || [ "$DNS_NAME" = "None" ]; then
          echo "Error: Could not get DNS name from CloudFormation stack"
          exit 1
        fi
        
        echo "Frontend URL: $DNS_NAME"
        
        # Extract protocol and hostname from URL
        if [[ "$DNS_NAME" == https://* ]]; then
          PROTOCOL="https"
          HOSTNAME=$(echo $DNS_NAME | sed 's|https://||')
        else
          PROTOCOL="http"
          HOSTNAME=$(echo $DNS_NAME | sed 's|http://||')
        fi
        
        echo "Testing health endpoints on: $PROTOCOL://$HOSTNAME"
        
        # Health checks for frontend
        if [ "$PROTOCOL" = "https" ]; then
          curl -f -k "https://$HOSTNAME/" || exit 1
          curl -f -k "https://$HOSTNAME/api/health" || exit 1
        else
          curl -f "http://$HOSTNAME/" || exit 1
          curl -f "http://$HOSTNAME/api/health" || exit 1
        fi

    - name: Force restart ECS services
      run: |
        aws ecs update-service \
          --cluster "admin-panel-release" \
          --service "admin-panel-service-release" \
          --force-new-deployment \
          --region "$AWS_REGION"
        
    - name: Debug deployment status
      run: |
        echo "=== Checking CloudFormation stack status ==="
        aws cloudformation describe-stacks \
          --stack-name AdminPanelReleaseStack \
          --region ${{ env.AWS_REGION }} \
          --query 'Stacks[0].StackStatus' \
          --output text || echo "Stack not found"
        
        echo "=== Getting actual ECS resources ==="
        # èŽ·å–å®žé™…çš„é›†ç¾¤åç§°
        CLUSTER_NAME="admin-panel-release"
        SERVICE_NAME="admin-panel-service-release"
        if [ ! -z "$CLUSTER_NAME" ]; then
          echo "Found cluster: $CLUSTER_NAME"
          
          # èŽ·å–æœåŠ¡åç§°
          if [ ! -z "$SERVICE_NAME" ]; then
            echo "Found service: $SERVICE_NAME"
            
            # æ£€æŸ¥æœåŠ¡çŠ¶æ€
            aws ecs describe-services \
              --cluster $CLUSTER_NAME \
              --services $SERVICE_NAME \
              --region ${{ env.AWS_REGION }} \
              --query 'services[0].{status:status,desiredCount:desiredCount,runningCount:runningCount,pendingCount:pendingCount}' \
              --output table || echo "Could not check ECS status"
          fi
        fi

    - name: Debug ECS task failures
      if: always()
      run: |
        echo "=== Checking for ECS tasks ==="
        # èŽ·å–é›†ç¾¤åç§°
        CLUSTER_NAME="admin-panel-release"
        
        if [ ! -z "$CLUSTER_NAME" ]; then
          TASK_ARNS=$(aws ecs list-tasks \
            --cluster $CLUSTER_NAME \
            --region ${{ env.AWS_REGION }} \
            --query 'taskArns' \
            --output text 2>/dev/null || echo "")
          
          if [ ! -z "$TASK_ARNS" ]; then
            echo "=== Task Details ==="
            aws ecs describe-tasks \
              --cluster $CLUSTER_NAME \
              --tasks $TASK_ARNS \
              --region ${{ env.AWS_REGION }} \
              --query 'tasks[].{taskArn:taskArn,lastStatus:lastStatus,desiredStatus:desiredStatus,stoppedReason:stoppedReason,healthStatus:healthStatus}' \
              --output table || echo "Could not get task details"
          else
            echo "No tasks found"
          fi
        fi

    - name: Create deployment summary
      if: success()
      run: |
        echo "## Release Deployment Successful! ðŸš€" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "- **Branch**: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Image Tag**: ${{ steps.image-tag.outputs.image_tag }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Frontend URL**: ${{ steps.alb-dns.outputs.alb-dns }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Deployed At**: $(date)" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Release Information" >> $GITHUB_STEP_SUMMARY
        echo "- **Week Number**: $(echo ${{ github.ref_name }} | sed 's/release-//')" >> $GITHUB_STEP_SUMMARY
        echo "- **Release Tag**: frontend-release-latest" >> $GITHUB_STEP_SUMMARY

  deployment-failure:
    needs: deploy-release
    runs-on: ubuntu-latest
    if: failure()
    steps:
      - name: Release Deployment Failed
        run: |
          echo "Release deployment failed - check the logs for details"
          echo "## Release Deployment Failed! âŒ" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch**: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Failed At**: $(date)" >> $GITHUB_STEP_SUMMARY
