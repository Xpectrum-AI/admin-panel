name: Deploy to Production

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  AWS_REGION: us-west-1
  ACCOUNT_ID: 641623447164

jobs:
  deploy-production:
    runs-on: ubuntu-latest
    environment: production
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build and push Frontend image to ECR
      run: |
        # Set ECR repository URI
        REPO="${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/admin-panel"
        
        # Build, tag, and push frontend only
        cd frontend
        docker build -t admin-panel:frontend-latest .
        docker tag admin-panel:frontend-latest $REPO:frontend-latest
        docker push $REPO:frontend-latest
        cd ..

    - name: Setup Python for CDK
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Install CDK dependencies
      run: |
        cd python-cdk-v2
        pip install -r requirements.txt

    - name: Install AWS CDK
      run: |
        npm install -g aws-cdk

    - name: Deploy CDK stack (production)
      run: |
        cd python-cdk-v2
        # Deploy to production environment
        timeout 30m cdk deploy AdminPanelProductionStack --require-approval never --context environment=production || {
          echo "CDK deployment timed out or failed"
          echo "Checking ECS service status..."
          aws ecs describe-services \
            --cluster AdminPanelProductionStack-AdminPanelCluster354587DC-WMnszSmI30dz \
            --services AdminPanelProductionStack-AdminPanelService167ECF01-mGcKXTWR0Ntv \
            --region ${{ env.AWS_REGION }} || echo "Could not check ECS status"
          exit 1
        }

    - name: Wait for deployment to complete
      run: |
        # Check if stack exists first
        if aws cloudformation describe-stacks --stack-name AdminPanelProductionStack --region ${{ env.AWS_REGION }} 2>/dev/null; then
          # Wait for ECS services to be stable
          aws ecs wait services-stable \
            --cluster AdminPanelProductionStack-AdminPanelCluster354587DC-WMnszSmI30dz \
            --services AdminPanelProductionStack-AdminPanelService167ECF01-mGcKXTWR0Ntv \
            --region ${{ env.AWS_REGION }} || echo "Services not stable yet"
        else
          echo "Stack does not exist yet, skipping wait"
        fi

    - name: Get ALB DNS name
      id: alb-dns
      run: |
        DNS_NAME=$(aws cloudformation describe-stacks \
          --stack-name AdminPanelProductionStack \
          --query 'Stacks[0].Outputs[?OutputKey==`FrontendURL`].OutputValue' \
          --output text \
          --region ${{ env.AWS_REGION }})
        echo "alb-dns=$DNS_NAME" >> $GITHUB_OUTPUT

    - name: Health check
      run: |
        # Wait for services to be fully ready
        sleep 60
        
        # Get ALB DNS name
        DNS_NAME=$(aws cloudformation describe-stacks \
          --stack-name AdminPanelProductionStack \
          --query 'Stacks[0].Outputs[?OutputKey==`FrontendURL`].OutputValue' \
          --output text \
          --region ${{ env.AWS_REGION }})
        
        # Check if DNS_NAME is not empty
        if [ -z "$DNS_NAME" ] || [ "$DNS_NAME" = "None" ]; then
          echo "Error: Could not get DNS name from CloudFormation stack"
          exit 1
        fi
        
        # Extract just the hostname from the URL
        HOSTNAME=$(echo $DNS_NAME | sed 's|https://||')
        
        echo "Testing health endpoints on: $HOSTNAME"
        
        # Health checks for frontend only (skip SSL verification)
        curl -f -k "https://$HOSTNAME/" || exit 1
        curl -f -k "https://$HOSTNAME/api/health" || exit 1

    - name: Create GitHub release
      if: success()
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: v${{ github.run_number }}
        release_name: Release v${{ github.run_number }}
        body: |
          Production deployment completed successfully
          
          **Changes:**
          - Commit: ${{ github.sha }}
          - Branch: ${{ github.ref_name }}
          
          **Services:**
          - Frontend: ✅ Deployed
          
          **Infrastructure:**
          - ECS Cluster: AdminPanelDeploymentStack-AdminPanelCluster
          - Load Balancer: ${{ steps.alb-dns.outputs.alb-dns }}
          
          **Health Checks:**
          - Frontend: ✅ Healthy
        draft: false
        prerelease: false

  deployment-failure:
    needs: deploy-production
    runs-on: ubuntu-latest
    if: failure()
    steps:
      - name: Production Deployment Failed
        run: |
          echo "Production deployment failed - check the logs for details" 