name: Deploy to Production

on:
  workflow_dispatch:
    inputs:
      admin_release_tag:
        description: 'Admin release image tag (e.g., admin-release-2025-01-15-001)'
        required: true
        type: string
      developer_release_tag:
        description: 'Developer release image tag (e.g., developer-release-2025-01-15-001)'
        required: true
        type: string

env:
  DIGITALOCEAN_REGION: sfo3

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "18"
          cache: "npm"
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        run: |
          cd frontend
          npm ci

      - name: Lint frontend
        run: |
          cd frontend
          npm run lint || echo "Lint completed with warnings"

      - name: Type check frontend
        run: |
          cd frontend
          npx tsc --noEmit || echo "Type check completed with warnings"

      - name: Run tests
        run: |
          cd frontend
          npm test -- --coverage --watchAll=false

  deploy-production:
    runs-on: ubuntu-latest
    environment: production
    needs: test

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js for Pulumi
        uses: actions/setup-node@v4
        with:
          node-version: "18"

      - name: Login to DigitalOcean Container Registry
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_TOKEN }}

      - name: Authenticate Docker with DOCR
        run: |
          doctl registry login --expiry-seconds 1200

      - name: Determine production tag for Admin Panel
        id: admin-prod-tag
        run: |
          set -e
          RELEASE_TAG="${{ inputs.admin_release_tag }}"
          if [ -z "$RELEASE_TAG" ]; then
            echo "‚ùå admin_release_tag input is required"
            exit 1
          fi

          if [[ ! "$RELEASE_TAG" =~ ^admin-release-[0-9]{4}-[0-9]{2}-[0-9]{2}-[0-9]{3}$ ]]; then
            echo "‚ùå admin_release_tag must look like admin-release-YYYY-MM-DD-###"
            exit 1
          fi

          DATE_PART=$(echo "$RELEASE_TAG" | sed -E 's/^admin-release-([0-9]{4}-[0-9]{2}-[0-9]{2})-.*/\1/')

          REPO="registry.digitalocean.com/xpectrum-main-app-dev/admin-prod"
          REPO_NAME="xpectrum-main-app-dev/admin-prod"
          TAG_PREFIX="admin-production-${DATE_PART}"

          echo "Release tag: $RELEASE_TAG"
          echo "Production tag prefix: $TAG_PREFIX"

          MAX_COUNTER=0
          FOUND_TAGS=false

          if command -v doctl >/dev/null 2>&1; then
            EXISTING_TAGS=$(doctl registry repository list-tags $REPO_NAME --format Tag --no-header 2>/dev/null || echo "")
            if [ -n "$EXISTING_TAGS" ]; then
              echo "Querying existing production tags via doctl..."
              for tag in $EXISTING_TAGS; do
                if [[ $tag == ${TAG_PREFIX}-* ]]; then
                  FOUND_TAGS=true
                  COUNTER=$(echo $tag | sed "s/${TAG_PREFIX}-//" | sed 's/^0*//')
                  if [ -z "$COUNTER" ]; then
                    COUNTER=0
                  fi
                  if [ "$COUNTER" -gt "$MAX_COUNTER" ] 2>/dev/null; then
                    MAX_COUNTER=$COUNTER
                  fi
                fi
              done
            fi
          fi

          if [ "$FOUND_TAGS" = false ]; then
            echo "Using docker manifest inspect fallback to find production tags..."
            for i in {1..999}; do
              COUNTER_FORMATTED=$(printf "%03d" $i)
              TEST_TAG="${TAG_PREFIX}-${COUNTER_FORMATTED}"
              if docker manifest inspect "$REPO:$TEST_TAG" >/dev/null 2>&1; then
                MAX_COUNTER=$i
                echo "Found existing production tag: $TEST_TAG"
              else
                break
              fi
            done
          fi

          NEW_COUNTER=$((MAX_COUNTER + 1))
          FORMATTED_COUNTER=$(printf "%03d" $NEW_COUNTER)
          PRODUCTION_TAG="${TAG_PREFIX}-${FORMATTED_COUNTER}"

          echo "Max existing production counter: $MAX_COUNTER"
          echo "Generated production tag: $PRODUCTION_TAG"
          echo "release_tag=$RELEASE_TAG" >> $GITHUB_OUTPUT
          echo "production_tag=$PRODUCTION_TAG" >> $GITHUB_OUTPUT

      - name: Determine production tag for Developer Dashboard
        id: developer-prod-tag
        run: |
          set -e
          RELEASE_TAG="${{ inputs.developer_release_tag }}"
          if [ -z "$RELEASE_TAG" ]; then
            echo "‚ùå developer_release_tag input is required"
            exit 1
          fi

          if [[ ! "$RELEASE_TAG" =~ ^developer-release-[0-9]{4}-[0-9]{2}-[0-9]{2}-[0-9]{3}$ ]]; then
            echo "‚ùå developer_release_tag must look like developer-release-YYYY-MM-DD-###"
            exit 1
          fi

          DATE_PART=$(echo "$RELEASE_TAG" | sed -E 's/^developer-release-([0-9]{4}-[0-9]{2}-[0-9]{2})-.*/\1/')

          REPO="registry.digitalocean.com/xpectrum-main-app-dev/developer-prod"
          REPO_NAME="xpectrum-main-app-dev/developer-prod"
          TAG_PREFIX="developer-production-${DATE_PART}"

          echo "Release tag: $RELEASE_TAG"
          echo "Production tag prefix: $TAG_PREFIX"

          MAX_COUNTER=0
          FOUND_TAGS=false

          if command -v doctl >/dev/null 2>&1; then
            EXISTING_TAGS=$(doctl registry repository list-tags $REPO_NAME --format Tag --no-header 2>/dev/null || echo "")
            if [ -n "$EXISTING_TAGS" ]; then
              echo "Querying existing production tags via doctl..."
              for tag in $EXISTING_TAGS; do
                if [[ $tag == ${TAG_PREFIX}-* ]]; then
                  FOUND_TAGS=true
                  COUNTER=$(echo $tag | sed "s/${TAG_PREFIX}-//" | sed 's/^0*//')
                  if [ -z "$COUNTER" ]; then
                    COUNTER=0
                  fi
                  if [ "$COUNTER" -gt "$MAX_COUNTER" ] 2>/dev/null; then
                    MAX_COUNTER=$COUNTER
                  fi
                fi
              done
            fi
          fi
          
          if [ "$FOUND_TAGS" = false ]; then
            echo "Using docker manifest inspect fallback to find production tags..."
            for i in {1..999}; do
              COUNTER_FORMATTED=$(printf "%03d" $i)
              TEST_TAG="${TAG_PREFIX}-${COUNTER_FORMATTED}"
              if docker manifest inspect "$REPO:$TEST_TAG" >/dev/null 2>&1; then
                MAX_COUNTER=$i
                echo "Found existing production tag: $TEST_TAG"
              else
                break
              fi
            done
          fi

          NEW_COUNTER=$((MAX_COUNTER + 1))
          FORMATTED_COUNTER=$(printf "%03d" $NEW_COUNTER)
          PRODUCTION_TAG="${TAG_PREFIX}-${FORMATTED_COUNTER}"

          echo "Max existing production counter: $MAX_COUNTER"
          echo "Generated production tag: $PRODUCTION_TAG"
          echo "release_tag=$RELEASE_TAG" >> $GITHUB_OUTPUT
          echo "production_tag=$PRODUCTION_TAG" >> $GITHUB_OUTPUT

      - name: Pull and tag Release Main Frontend image for Production
        run: |
          RELEASE_REPO="registry.digitalocean.com/xpectrum-main-app-dev/admin-release"
          PROD_REPO="registry.digitalocean.com/xpectrum-main-app-dev/admin-prod"
          RELEASE_TAG="${{ steps.admin-prod-tag.outputs.release_tag }}"
          PROD_TAG="${{ steps.admin-prod-tag.outputs.production_tag }}"
          
          echo "üì• Pulling release image: $RELEASE_REPO:$RELEASE_TAG"
          docker pull $RELEASE_REPO:$RELEASE_TAG
          
          echo "üè∑Ô∏è Tagging release image as production with tag: $PROD_REPO:$PROD_TAG"
          docker tag $RELEASE_REPO:$RELEASE_TAG $PROD_REPO:$PROD_TAG
          
          echo "üì§ Pushing production image: $PROD_REPO:$PROD_TAG"
          docker push $PROD_REPO:$PROD_TAG
          
          echo "üè∑Ô∏è Updating latest tag for convenience"
          docker tag $RELEASE_REPO:$RELEASE_TAG $PROD_REPO:latest
          docker push $PROD_REPO:latest
          
          echo "‚úÖ Successfully promoted $RELEASE_TAG -> $PROD_TAG"

      - name: Pull and tag Release Developer Frontend image for Production
        run: |
          RELEASE_REPO="registry.digitalocean.com/xpectrum-main-app-dev/developer-release"
          PROD_REPO="registry.digitalocean.com/xpectrum-main-app-dev/developer-prod"
          RELEASE_TAG="${{ steps.developer-prod-tag.outputs.release_tag }}"
          PROD_TAG="${{ steps.developer-prod-tag.outputs.production_tag }}"
          
          echo "üì• Pulling release image: $RELEASE_REPO:$RELEASE_TAG"
          docker pull $RELEASE_REPO:$RELEASE_TAG
          
          echo "üè∑Ô∏è Tagging release image as production with tag: $PROD_REPO:$PROD_TAG"
          docker tag $RELEASE_REPO:$RELEASE_TAG $PROD_REPO:$PROD_TAG
          
          echo "üì§ Pushing production image: $PROD_REPO:$PROD_TAG"
          docker push $PROD_REPO:$PROD_TAG
          
          echo "üè∑Ô∏è Updating latest tag for convenience"
          docker tag $RELEASE_REPO:$RELEASE_TAG $PROD_REPO:latest
          docker push $PROD_REPO:latest
          
          echo "‚úÖ Successfully promoted $RELEASE_TAG -> $PROD_TAG"

      - name: Install Pulumi CLI
        uses: pulumi/actions@v4
        with:
          pulumi-version: latest

      - name: Install Pulumi dependencies
        run: |
          cd digital-ocean-deployment
          npm ci

      - name: Check and create Pulumi stack if needed
        working-directory: digital-ocean-deployment
        env:
          PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }}
        run: |
          # Check if stack exists, if not create it
          if pulumi stack select frontend-prod 2>/dev/null; then
            echo "‚úÖ Stack 'frontend-prod' already exists, using it"
          else
            echo "üì¶ Stack 'frontend-prod' does not exist, creating it..."
            pulumi stack init frontend-prod
            echo "‚úÖ Stack 'frontend-prod' created successfully"
          fi

      - name: Configure Pulumi from GitHub secrets
        working-directory: digital-ocean-deployment
        env:
          DIGITALOCEAN_TOKEN: ${{ secrets.DIGITALOCEAN_TOKEN }}
          PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }}
        run: |
          # Select the stack (required before setting config)
          pulumi stack select frontend-prod
          
          # Set DigitalOcean token (required - from GitHub secret)
          pulumi config set digitalocean:token $DIGITALOCEAN_TOKEN --secret
          
          # Set region (required - from env variable)
          pulumi config set index:region ${{ env.DIGITALOCEAN_REGION }}
          
          # Admin Panel and Developer Dashboard share the same namespace (prod:)
          # Both use the same propelauthApiKey and propelauthUrl config keys
          # Using Developer Dashboard values since they're more specific
          pulumi config set prod:propelauthApiKey "${{ secrets.PRODUCTION_PROPELAUTH_API_KEY }}" --secret
          pulumi config set prod:liveApiKey "${{ secrets.PRODUCTION_LIVE_API_KEY }}" --secret
          pulumi config set prod:propelauthUrl "${{ vars.PRODUCTION_DEVELOPMENT_PROPELAUTH_URL }}"
          pulumi config set prod:liveApiUrl "${{ vars.PRODUCTION_LIVE_API_URL }}"
          pulumi config set prod:superAdminOrgId "${{ secrets.PRODUCTION_SUPER_ADMIN_ORG_ID }}"
          
          # Developer Dashboard secrets - using PRODUCTION_* secrets, storing in prod: namespace
          pulumi config set prod:difyAdminPassword "${{ secrets.PRODUCTION_DIFY_ADMIN_PASSWORD }}" --secret
          pulumi config set prod:modelOpenAiApiKey "${{ secrets.PRODUCTION_MODEL_OPEN_AI_API_KEY }}" --secret
          pulumi config set prod:modelGroqApiKey "${{ secrets.PRODUCTION_MODEL_GROQ_API_KEY }}" --secret
          pulumi config set prod:modelAnthropicApiKey "${{ secrets.PRODUCTION_MODEL_ANTHROPIC_API_KEY }}" --secret
          pulumi config set prod:chatbotApiKey "${{ secrets.PRODUCTION_CHATBOT_API_KEY }}" --secret
          pulumi config set prod:elevenLabsApiKey "${{ secrets.PRODUCTION_ELEVEN_LABS_API_KEY }}" --secret
          pulumi config set prod:openAiApiKey "${{ secrets.PRODUCTION_OPEN_AI_API_KEY }}" --secret
          pulumi config set prod:whisperApiKey "${{ secrets.PRODUCTION_WHISPER_API_KEY }}" --secret
          pulumi config set prod:deepgramApiKey "${{ secrets.PRODUCTION_DEEPGRAM_API_KEY }}" --secret
          pulumi config set prod:cartesiaApiKey "${{ secrets.PRODUCTION_CARTESIA_API_KEY }}" --secret
          
          # Developer Dashboard config values - using PRODUCTION_* vars, storing in prod: namespace
          # Note: propelauthUrl already set above (shared with Admin Panel)
          pulumi config set prod:apiBaseUrl "${{ vars.PRODUCTION_MODEL_API_BASE_URL }}"
          pulumi config set prod:enableEmailVerification "true"
          pulumi config set prod:difyConsoleOrigin "${{ vars.PRODUCTION_DIFY_CONSOLE_ORIGIN }}"
          pulumi config set prod:difyAdminEmail "${{ vars.PRODUCTION_DIFY_ADMIN_EMAIL }}"
          pulumi config set prod:difyWorkspaceId "${{ vars.PRODUCTION_DIFY_WORKSPACE_ID }}"
          pulumi config set prod:difyBaseUrl "${{ vars.PRODUCTION_DIFY_BASE_URL }}"
          pulumi config set prod:chatbotApiUrl "${{ vars.PRODUCTION_CHATBOT_API_URL }}"
          pulumi config set prod:cartesiaVoiceId "${{ vars.PRODUCTION_CARTESIA_VOICE_ID }}"
          pulumi config set prod:elevenLabsVoiceId "${{ vars.PRODUCTION_ELEVEN_LABS_VOICE_ID }}"
          pulumi config set prod:liveApiUrl "${{ vars.PRODUCTION_LIVE_API_URL }}"
          
          # Set image tags (from generated production tags)
          pulumi config set prod:adminImageTag "${{ steps.admin-prod-tag.outputs.production_tag }}"
          pulumi config set prod:developerImageTag "${{ steps.developer-prod-tag.outputs.production_tag }}"
          
          echo "‚úÖ Pulumi config fully configured from GitHub secrets and variables"

      - name: Deploy with Pulumi
        working-directory: digital-ocean-deployment
        env:
          DIGITALOCEAN_TOKEN: ${{ secrets.DIGITALOCEAN_TOKEN }}
          PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }}
        run: |
          # Select the stack
          pulumi stack select frontend-prod
          
          # Deploy updates
          pulumi up --yes

      - name: Get deployment URLs
        id: pulumi-outputs
        working-directory: digital-ocean-deployment
        env:
          PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }}
        run: |
          pulumi stack select frontend-prod
          ADMIN_URL=$(pulumi stack output adminPanelUrl 2>/dev/null || echo "")
          DEVELOPER_URL=$(pulumi stack output developerDashboardUrl 2>/dev/null || echo "")
          
          echo "admin-url=$ADMIN_URL" >> $GITHUB_OUTPUT
          echo "developer-url=$DEVELOPER_URL" >> $GITHUB_OUTPUT
          
          echo "Admin Panel URL: $ADMIN_URL"
          echo "Developer Dashboard URL: $DEVELOPER_URL"

      - name: Wait for apps to be ready
        run: |
          echo "Waiting for DigitalOcean apps to be ready..."
          sleep 90

      - name: Health check
        run: |
          ADMIN_URL="${{ steps.pulumi-outputs.outputs.admin-url }}"
          DEVELOPER_URL="${{ steps.pulumi-outputs.outputs.developer-url }}"
          
          if [ -z "$ADMIN_URL" ] || [ "$ADMIN_URL" = "" ]; then
            echo "Warning: Could not get Admin Panel URL from Pulumi outputs"
            ADMIN_URL="https://admin-prod.xpectrum-ai.com"
          fi
          
          if [ -z "$DEVELOPER_URL" ] || [ "$DEVELOPER_URL" = "" ]; then
            echo "Warning: Could not get Developer Dashboard URL from Pulumi outputs"
            DEVELOPER_URL="https://developer-prod.xpectrum-ai.com"
          fi
          
          echo "Testing Admin Panel health endpoints on: $ADMIN_URL"
          echo "Testing Developer Dashboard health endpoints on: $DEVELOPER_URL"
          
          # Health checks for Admin Panel
          curl -f -k "$ADMIN_URL/" || echo "Admin Panel root endpoint check failed"
          curl -f -k "$ADMIN_URL/api/health" || echo "Admin Panel health endpoint check failed"
          
          # Health checks for Developer Dashboard
          curl -f -k "$DEVELOPER_URL/" || echo "Developer Dashboard root endpoint check failed"
          curl -f -k "$DEVELOPER_URL/api/health" || echo "Developer Dashboard health endpoint check failed"
          
          echo "Health checks completed"

      - name: Display deployment info
        run: |
          echo "üéâ Production Deployment Complete!"
          echo "üì¶ Admin Panel Image: registry.digitalocean.com/xpectrum-main-app-dev/admin-prod:${{ steps.admin-prod-tag.outputs.production_tag }}"
          echo "üì¶ Developer Dashboard Image: registry.digitalocean.com/xpectrum-main-app-dev/developer-prod:${{ steps.developer-prod-tag.outputs.production_tag }}"
          echo "üåç Environment: production"
          echo "üîß Stack: frontend-prod"

      - name: Record deployment to tracking files
        run: |
          set -e
          
          # Get deployment information
          DEPLOYMENT_DATE=$(date -u +"%Y-%m-%d %H:%M:%S UTC")
          DEPLOYMENT_DATE_ISO=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          COMMIT_SHA="${{ github.sha }}"
          DEPLOYED_BY="${{ github.actor }}"
          PLATFORM="DigitalOcean"
          
          ADMIN_RELEASE_TAG="${{ steps.admin-prod-tag.outputs.release_tag }}"
          ADMIN_PROD_TAG="${{ steps.admin-prod-tag.outputs.production_tag }}"
          DEVELOPER_RELEASE_TAG="${{ steps.developer-prod-tag.outputs.release_tag }}"
          DEVELOPER_PROD_TAG="${{ steps.developer-prod-tag.outputs.production_tag }}"
          
          ADMIN_URL="${{ steps.pulumi-outputs.outputs.admin-url }}"
          DEVELOPER_URL="${{ steps.pulumi-outputs.outputs.developer-url }}"
          
          # Create deployment record JSON
          DEPLOYMENT_JSON=$(cat <<EOF
          {
            "deploymentDate": "$DEPLOYMENT_DATE_ISO",
            "platform": "$PLATFORM",
            "adminReleaseTag": "$ADMIN_RELEASE_TAG",
            "adminProductionTag": "$ADMIN_PROD_TAG",
            "developerReleaseTag": "$DEVELOPER_RELEASE_TAG",
            "developerProductionTag": "$DEVELOPER_PROD_TAG",
            "deployedBy": "$DEPLOYED_BY",
            "commitSha": "$COMMIT_SHA",
            "adminUrl": "${ADMIN_URL:-N/A}",
            "developerUrl": "${DEVELOPER_URL:-N/A}",
            "status": "Success",
            "workflowRunId": "${{ github.run_id }}",
            "workflowRunUrl": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          }
          EOF
          )
          
          # Read existing deployments JSON
          if [ -f "deployments/production-deployments.json" ]; then
            # Use jq if available, otherwise use Python
            if command -v jq >/dev/null 2>&1; then
              # Prepend new deployment to the deployments array
              jq --argjson newDeployment "$DEPLOYMENT_JSON" '.deployments = [$newDeployment] + .deployments | .lastUpdated = now' deployments/production-deployments.json > deployments/production-deployments.json.tmp
              mv deployments/production-deployments.json.tmp deployments/production-deployments.json
            else
              # Fallback to Python
              python3 <<PYTHON_SCRIPT
          import json
          import sys
          from datetime import datetime
          
          with open('deployments/production-deployments.json', 'r') as f:
              data = json.load(f)
          
          new_deployment = json.loads('''$DEPLOYMENT_JSON''')
          data['deployments'].insert(0, new_deployment)
          data['lastUpdated'] = datetime.utcnow().isoformat() + 'Z'
          
          with open('deployments/production-deployments.json', 'w') as f:
              json.dump(data, f, indent=2)
          PYTHON_SCRIPT
            fi
          else
            echo "Warning: deployments/production-deployments.json not found, creating it..."
            mkdir -p deployments
            cat > deployments/production-deployments.json <<EOF
          {
            "deployments": [$DEPLOYMENT_JSON],
            "lastUpdated": "$DEPLOYMENT_DATE_ISO",
            "metadata": {
              "description": "Production deployment history tracking which images were deployed to production",
              "format": "1.0"
            }
          }
          EOF
          fi
          
          # Update Markdown file
          MARKDOWN_ROW="| $DEPLOYMENT_DATE | $PLATFORM | \`$ADMIN_RELEASE_TAG\` | \`$ADMIN_PROD_TAG\` | \`$DEVELOPER_RELEASE_TAG\` | \`$DEVELOPER_PROD_TAG\` | $DEPLOYED_BY | \`${COMMIT_SHA:0:7}\` | ‚úÖ Success |"
          
          if [ -f "deployments/PRODUCTION_DEPLOYMENTS.md" ]; then
            # Insert new row after the header row (line 5)
            sed -i "5a\\$MARKDOWN_ROW" deployments/PRODUCTION_DEPLOYMENTS.md
          else
            echo "Warning: deployments/PRODUCTION_DEPLOYMENTS.md not found, creating it..."
            mkdir -p deployments
            cat > deployments/PRODUCTION_DEPLOYMENTS.md <<EOF
          # Production Deployment History
          
          This file tracks all production deployments, including which release images were promoted to production.
          
          ## Deployment Log
          
          | Date | Platform | Admin Release Tag | Admin Production Tag | Developer Release Tag | Developer Production Tag | Deployed By | Commit SHA | Status |
          |------|----------|-------------------|---------------------|----------------------|-------------------------|-------------|------------|--------|
          $MARKDOWN_ROW
          
          ---
          
          ## Notes
          
          - **Release Tag**: The source image tag from the release environment
          - **Production Tag**: The production image tag created during deployment
          - **Platform**: Either "DigitalOcean" or "AWS"
          - **Status**: "Success" or "Failed"
          
          ---
          
          *This file is automatically updated by the deployment workflows.*
          EOF
          fi
          
          echo "‚úÖ Deployment recorded to tracking files"

  deployment-failure:
    needs: deploy-production
    runs-on: ubuntu-latest
    if: failure()
    steps:
      - name: Production Deployment Failed
        run: |
          echo "Production deployment failed - check the logs for details"
